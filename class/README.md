# Class

객체를 쉽게 만들 수 있는 템플릿

1. 생성자 함수 (하지만 요즘은 거의 사용하지 않는다)
2. 클래스

- 생성자 함수나 클래스를 통해 만들어진 객체를 인스턴스라고 한다.

<br>

### constructor

인스턴스를 생성하고 클래스 필드(클래스 내부의 캡슐화된 변수)를 초기화하기 위한 특수 메소드

- `new` 연산자로 constructor를 호출하면서 필요한 데이터를 인자로 받아 객체(인스턴스)를 생성한다.
- 생략 가능하다. 빈 객체를 생성할 뿐 프로퍼티 추가가 필요하면 인스턴스 생성 후 동적 추가하면 된다.

<br>

### 정적 프로퍼티/메소드

- 모든 객체마다 동일하게 참조해야하는 속성이나 메소드가 있다면, 클래스 레벨의 프로퍼티와 메소드를 사용하는게 좋다.
- 클래스 레벨로 갈 속성, 메소드 앞에는 `static` 키워드를 붙여준다.
- 클래스는 아무것도 채워지지 않은 템플릿이므로 클래스 레벨 메소드에선 this를 참조할 수 없다.
- 클래스 레벨의 속성, 메소드이므로 가져올 때도 인스턴스가 아닌 클래스가 호출해야한다.

> 비슷한 내용의 함수들을 묶어서 관리하고 싶은데 인스턴스(객체)를 굳이 만들지 않고싶다면, <br>정적메소드로만 class를 구성하는게 좋다! 마치 `Math` 내장 객체처럼 말이다.

<br>

### 접근 제어자

- 접근 제어자로 내부의 속성이나 메소드를 외부에 노출시키지 않게 캡슐화할 수 있다.
- public은 default, 굳이 접근 제어자를 붙이지 않아도 된다.
- `private(#)` 속성이나 메소드 앞에 #을 붙이면 외부에 노출되지 않아서 변경도 불가하다.

<br>

### getter, setter

- 기존 프로퍼티를 가지고 다른 속성을 만드는 경우, 메소드 형태로 만들게 되서 속성에 접근하는 것처럼 `객체.속성` 으로 접근하는 게 아니라 함수를 호출하듯이 `객체.속성()` 로 속성값을 가져오게 된다.
- 그렇다고 메소드형태가 아닌 생성자 함수에 이를 정의하게 된다면, **`constructor` 함수는 인스턴스를 생성할 때 딱 한번만 실행되기 때문에** 그 이후에 그 속성값과 연관된 다른 속성들이 변경되었을 때 해당값이 업데이트가 되지 않는다. (직접 재할당해서 변경해주지 않는 이상)
- ✨ 이 때 필요한게 `getter` 와 `setter` 이다!

<br>

1. `get`

- 함수호출 형태가 아닌 프로퍼티 접근하듯이 값을 가져올 수 있다.
- 해당 속성을 읽을 때 getter가 호출된다. 따라서 속성값을 가져오는 시점에 데이터를 매번 다시 만들기 때문에 연관된 다른 값들이 변경된다면 그에 따라 업데이트된 값을 얻을 수 있다!

<br>

2. `set`

- 해당 속성에 값을 할당할 때 `setter`가 호출된다.

> 뭔가를 처리하는 행위는 아닌데 다른 속성값을 조합해서 만들거나, 속성 접근(get) 및 속성값 할당(set) 할 때 특정한 일을 해주고 싶다면 getter와 setter를 유용하게 사용 가능하다. <br> ex) validation 체크, 값 제한 등...

<br>

### 상속

- 클래스마다 공통된 행동이나 속성이 있다면, 상속을 사용한다.
- `extends` 키워드를 사용해서 상속한다.
- `super` 키워드르 사용해서 부모의 constructor 함수를 호출할수도 있고 (`super(arg)`),
- 부모의 메소드를 가져다가 참조하기도 하고 추가적인 메소드를 만들기도 한다. (`super.메소드()`)

- 상속을 통해 overriding하여 클래스별로 확장도 가능하다.
  > overriding : 상위 클래스가 가지고 있는 메소드를 하위 클래스가 재정의해서 사용하는 방식
